<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Tag: C++
  
</title>

<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="LeekinBlog">
<meta property="og:url" content="http://leekingta.github.io/blog/tags/C/index.html">
<meta property="og:site_name" content="LeekinBlog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeekinBlog">
<meta name="twitter:description">


  <link rel="alternative" href="/atom.xml" title="LeekinBlog" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/blog/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/blog/styles/main.css">






</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/blog/">LeekinBlog</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/blog/">LeekinBlog</a></h1>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">Leekin</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="https://avatars3.githubusercontent.com/u/12389136?v=3&amp;s=460"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">Category</a>
                
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">Tag</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/C/">C++</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Shell-Programing/">Shell Programing</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/git使用/">git使用</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/个人简历/">个人简历</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/游戏引擎/">游戏引擎</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">Archive</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/">2016</a><span class="archive-list-count">10</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/blog/" title="首页">首页</a>
              </li>
            
          
            
              <li>
                <a href="/blog/archives" title="归档">归档</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/LeekinGTA/blog" title="博客仓库" target="_blank" rel="external">博客仓库</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/LeekinGTA" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
            
              <li>
                <a href="/blog/atom.xml" title="RSS">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <h1>C++</h1>


  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2016/08/22/C-标准模板库/" >
  C++标准模板库
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2016/08/22/C-标准模板库/"><span class="article-date">
  2016-08-22
</span>
</a>
        

        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C/">C++</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <h4 id="容器是储存其他对象的对象"><a href="#容器是储存其他对象的对象" class="headerlink" title=" 容器是储存其他对象的对象 "></a><strong> 容器是储存其他对象的对象 </strong></h4><h2 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. vector</h2><blockquote>
<p>标准模板库vector是在编程过程中常用的容器，可以创建vector对象，将一个vector对象赋给另一个对象，使用[]符号来访问vector元素，要想使类成为通用的，将它设计为模板类，vector正是这样的类。下面是vector的函数原型：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> Allocator=allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">vector</span>&#123;...........&#125; <span class="comment">//其中，Allocator指明使用的内存分配方式，如果省略该值，默认将使用allocator&lt;T&gt;,即new和delete的方式来分配内存</span></span><br></pre></td></tr></table></figure>
<p><strong>vector模板函数(特定算法)</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">函数名</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Size()</td>
<td style="text-align:right">返回元素中元素数目</td>
</tr>
<tr>
<td style="text-align:left">Swap()</td>
<td style="text-align:right">交换两个容器的内容</td>
</tr>
<tr>
<td style="text-align:left">begin()</td>
<td style="text-align:right">返回一个指向容器中第一个元素的迭代器</td>
</tr>
<tr>
<td style="text-align:left">end()</td>
<td style="text-align:right">返回一个表示超过容器尾的迭代器(迭代器是一个广义指针)</td>
</tr>
<tr>
<td style="text-align:left">push_back()</td>
<td style="text-align:right">将元素添加到矢量末尾</td>
</tr>
<tr>
<td style="text-align:left">erase()</td>
<td style="text-align:right">删除矢量中给定区间的元素</td>
</tr>
<tr>
<td style="text-align:left">insert()</td>
<td style="text-align:right">向矢量中插入元素，方法接受三个参数</td>
</tr>
</tbody>
</table>
<p><strong>声明一个迭代器</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::iterator pd;</span><br></pre></td></tr></table></figure></p>
<p><strong> 特定算法与通用算法 </strong></p>
<blockquote>
<p><strong>特定算法</strong>:指的是在整个容器家族中，大多数容器都包含自己特定的算法，这种算法只能用于本容器。</p>
<p><strong>通用算法</strong>:指的是在在容器家族中共用的函数，这些函数在设计的时候单独做了封装，这是为了减少重复代码，真正体现OOP的理念，如果通用算法被包含在模板类当中，那么相同的算法将要重复写入所有模板类中。</p>
</blockquote>
<p><strong> 下面是通用算法列表 </strong><br><figure class="highlight plain"><figcaption><span>for_each</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each()函数能够遍历容器，函数接受三个参数，前两个参数指定访问的区间，第三个参数接受一个函数指针，将访问到的元素交给第三个参数处理。</span><br></pre></td></tr></table></figure><br><em>for_each例子:</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(book.begin(),book.end(),out);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>Random_shuffle</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random_shuffle()函数接受两个迭代器参数,并随机排列该区间的元素。</span><br></pre></td></tr></table></figure>
<p><em>Random_shuffle例子:</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random_shuffle(book.begin(),book.end());</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>sort()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort()函数有两个版本，１.sort()接受两个参数，指定要进行排序的区间，并对其进行排序操作，排序时使用内置的&lt;运算符进行比较。２.第二个版本需要我们指定排序的规则，即在类中定义operator&lt;()函数，当我们使用sort()函数时，就使用我们指定的函数来进行排序操作。</span><br></pre></td></tr></table></figure>
<h2 id="2-迭代器类型"><a href="#2-迭代器类型" class="headerlink" title="2. 迭代器类型"></a>2. 迭代器类型</h2><ul>
<li><h3 id="输入迭代器-能够从容器中读入值，不会修改容器中的值。"><a href="#输入迭代器-能够从容器中读入值，不会修改容器中的值。" class="headerlink" title="输入迭代器:能够从容器中读入值，不会修改容器中的值。"></a>输入迭代器:能够从容器中读入值，不会修改容器中的值。</h3></li>
<li><h3 id="输出迭代器：能够向容器中写入值，不能读取值。"><a href="#输出迭代器：能够向容器中写入值，不能读取值。" class="headerlink" title="输出迭代器：能够向容器中写入值，不能读取值。"></a>输出迭代器：能够向容器中写入值，不能读取值。</h3></li>
<li><h3 id="正向迭代器-即可以读取值也可以修改值。"><a href="#正向迭代器-即可以读取值也可以修改值。" class="headerlink" title="正向迭代器: 即可以读取值也可以修改值。"></a>正向迭代器: 即可以读取值也可以修改值。</h3></li>
<li><h3 id="双向迭代器-双向迭代器支持正向迭代器的所有特性，同时支持两种递减运算符-前坠与后缀-。"><a href="#双向迭代器-双向迭代器支持正向迭代器的所有特性，同时支持两种递减运算符-前坠与后缀-。" class="headerlink" title="双向迭代器: 双向迭代器支持正向迭代器的所有特性，同时支持两种递减运算符(前坠与后缀)。"></a>双向迭代器: 双向迭代器支持正向迭代器的所有特性，同时支持两种递减运算符(前坠与后缀)。</h3></li>
<li><h3 id="随机访问迭代器-随机访问迭代器具备双向迭代器的所有特性，它能够直接跳到容器中的任何一个元素，同时添加对元素的随机访问操作功能。"><a href="#随机访问迭代器-随机访问迭代器具备双向迭代器的所有特性，它能够直接跳到容器中的任何一个元素，同时添加对元素的随机访问操作功能。" class="headerlink" title="随机访问迭代器:随机访问迭代器具备双向迭代器的所有特性，它能够直接跳到容器中的任何一个元素，同时添加对元素的随机访问操作功能。"></a>随机访问迭代器:随机访问迭代器具备双向迭代器的所有特性，它能够直接跳到容器中的任何一个元素，同时添加对元素的随机访问操作功能。</h3></li>
</ul>
<h2 id="3-所有容器列表"><a href="#3-所有容器列表" class="headerlink" title="3.所有容器列表"></a>3.所有容器列表</h2><hr>
<h3 id="deque-list-queue-Priority-queue-stack-vector-map-multimap-set-multiset-bitset"><a href="#deque-list-queue-Priority-queue-stack-vector-map-multimap-set-multiset-bitset" class="headerlink" title="deque list queue Priority_queue stack vector map multimap set multiset bitset"></a><code>deque</code> <code>list</code> <code>queue</code> <code>Priority_queue</code> <code>stack</code> <code>vector</code> <code>map</code> <code>multimap</code> <code>set</code> <code>multiset</code> <code>bitset</code></h3><h3 id="C-11新增-forward-list-unordered-map-unordered-multimap-unordered-set-unordered-multiset"><a href="#C-11新增-forward-list-unordered-map-unordered-multimap-unordered-set-unordered-multiset" class="headerlink" title=" C++11新增: forward_list unordered_map unordered_multimap unordered_set unordered_multiset"></a><strong> C++11新增:</strong> <code>forward_list</code> <code>unordered_map</code> <code>unordered_multimap</code> <code>unordered_set</code> <code>unordered_multiset</code></h3><hr>
<h2 id="4-deque"><a href="#4-deque" class="headerlink" title="4. deque:"></a>4. deque:</h2><blockquote>
<p>双端队列，类似于vector容器，支持随机访问，与vector的主要区别：deque对象的开始位置插入和删除元素的时间是固定的，而vector是线性时间，适用于多数操作发生在序列的起始和结尾处，则考虑使用deque。</p>
</blockquote>
<h2 id="5-list"><a href="#5-list" class="headerlink" title="5.list"></a>5.list</h2><blockquote>
<p>双向链表，除了第一个和最后一个元素外，每个元素都与前后的元素相链接，可以双向遍历链表，与vector不同的是:list不支持数组表示法和随机访问。与矢量迭代器不同，从容器中插入或删除元素之后，链表迭代器指向的元素不变。unique()方法删除重复的元素.</p>
</blockquote>
<h2 id="6-forward-list"><a href="#6-forward-list" class="headerlink" title="6. forward_list"></a>6. forward_list</h2><blockquote>
<p>单链表，每个节点都只链接到下一个节点，而没有链接到前一个节点，forward_list只需要正向迭代器，而不需要双向迭代器，forward_list是不可反转的容器，相比于list，forward_list更简单，更紧凑，但功能更少。</p>
</blockquote>
<h2 id="7-queue"><a href="#7-queue" class="headerlink" title="7. queue"></a>7. queue</h2><blockquote>
<p>queue是一个适配器，如：Ostream_iterator模板是一个适配器，让输出流能够使用迭代器接口；queue模板让底层类展示典型的队列接口，queue的限制比deque的多，它不允许随机访问列队元素，不引许遍历队列，它把使用限制在定义列队的基本操作之上，可以将元素添加到队尾，从队首删除元素，查看队首和队尾的值，检查元素数目和测试队列是否为空。</p>
</blockquote>
<p><strong>queue函数列表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">empty()</td>
<td style="text-align:left">检查队列是否为空</td>
</tr>
<tr>
<td style="text-align:center">Size()</td>
<td style="text-align:left">返回队列的数目</td>
</tr>
<tr>
<td style="text-align:center">front()</td>
<td style="text-align:left">返回队尾元素的引用</td>
</tr>
<tr>
<td style="text-align:center">push(const T&amp;x)</td>
<td style="text-align:left">在队尾插入x</td>
</tr>
<tr>
<td style="text-align:center">pop()</td>
<td style="text-align:left">删除队首元素</td>
</tr>
</tbody>
</table>
<h2 id="8-Priority-queue"><a href="#8-Priority-queue" class="headerlink" title="8. Priority_queue"></a>8. Priority_queue</h2><blockquote>
<p>Priority_queue在queue头文件中，是另一个适配器，他支持的操作与queue相同，区别在于Priority_queue中最大的元素被移到队首，内部区别：Priority_queue的底层类是vector，可以修改用于确定哪个元素被放到队首的比较方法，方法是提供一个可选的构造函数：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Priority_queue&lt;<span class="keyword">int</span>&gt; pq1;</span><br><span class="line">Priority_queue&lt;<span class="keyword">int</span>&gt; pq2(greater&lt;<span class="keyword">int</span>&gt;);<span class="comment">//greater&lt;&gt;()是一个预定义函数对象。</span></span><br></pre></td></tr></table></figure>
<h2 id="9-stack"><a href="#9-stack" class="headerlink" title="9. stack"></a>9. stack</h2><blockquote>
<p>与queue相同，stack也是一个适配器类，他给底层提供了典型的栈接口，stack的限制比vector更多，他不仅不允许随机访问栈元素，甚至不允许遍历栈，他把使用限制在定义栈的基本操作上，既可以将压入推到栈顶，从栈顶弹出元素，查看栈顶的值，检查元素数目和测试栈是否为空。</p>
</blockquote>
<p><strong> stack 函数</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bool empty() const</td>
<td style="text-align:center">检查栈是否为空</td>
</tr>
<tr>
<td style="text-align:center">Size_type Size() const</td>
<td style="text-align:center">返回栈的大小</td>
</tr>
<tr>
<td style="text-align:center">T&amp; top()</td>
<td style="text-align:center">返回栈顶元素引用</td>
</tr>
<tr>
<td style="text-align:center">void push(const T &amp;x)</td>
<td style="text-align:center">在栈顶部插入x</td>
</tr>
<tr>
<td style="text-align:center">void pop()</td>
<td style="text-align:center">删除栈顶元素</td>
</tr>
</tbody>
</table>
<h2 id="10-array-C-11"><a href="#10-array-C-11" class="headerlink" title="10.array (C++11)"></a>10.array (C++11)</h2><blockquote>
<p>array并不是STL容器，因为其长度是固定的。因此，array没有定义调整容器大小的操作，如: push_back()和insert()，但定义如operator<a href=""></a>和at()，可将很多标准STL算法用于array对象，如copy()和for_each()</p>
</blockquote>
<h2 id="11-set"><a href="#11-set" class="headerlink" title="11. set"></a>11. set</h2><blockquote>
<p>set是一个关联容器，关联容器是对容器的一个改进，它将值与键关联在一起，并使用键来查找值。关联容器的优点在于提供对元素的快速访问，不能指定新元素的插入位置，关联容器通常是树的数据结构，相对于链表，树的查找速度更快。set是最简单的关联容器，其值类型与键相同，键是唯一的，这意味着集合中不会有多个相同的元素，对于set来说，值就是键。例如：4-2,1-5,8-8</p>
</blockquote>
<h2 id="12-multiset"><a href="#12-multiset" class="headerlink" title="12. multiset"></a>12. multiset</h2><p>multiset类似于set，只是可能有多个值的键相同,例如：４－２，５－２，６－３，８－３。</p>
<h2 id="13-map"><a href="#13-map" class="headerlink" title="13. map"></a>13. map</h2><p>map中，键与值的类型不同，键是唯一的，每个键对应一个值，如：１－CPP,2－JAVA,3－JAVASCRIPT</p>
<h2 id="14-multimap"><a href="#14-multimap" class="headerlink" title="14.multimap"></a>14.multimap</h2><blockquote>
<p>multimap与map相似，只是一个键可以有多个值关联。</p>
</blockquote>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2016/05/22/C-enum/" >
  C++ enum
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2016/05/22/C-enum/"><span class="article-date">
  2016-05-22
</span>
</a>
        

        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C/">C++</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <h1 id="C-枚举类型详细介绍"><a href="#C-枚举类型详细介绍" class="headerlink" title="C++枚举类型详细介绍"></a>C++枚举类型详细介绍</h1><img src="/blog/2016/05/22/C-enum/xing22.jpg" alt="这是一个装饰图" title="这是一个装饰图">
<blockquote>
<p>在具体的编程工作当中，枚举类型多用来创建常量，取代const。</p>
</blockquote>
<ol>
<li>声明枚举类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color&#123;red,orange,yellow,green,blue&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>声明枚举类型之后我们要知道他里面储存的值是多少，在默认的情况下枚举值是从0依次递增的，当然我们也可一给他赋值：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color&#123;red=<span class="number">100</span>,orange,yellow,green,blue&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>red=100之后，理所当然后面的值也应该递增，orange=101,yellow=102,green=103,blue=104。如果是这种情况呢？：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color&#123;red=<span class="number">100</span>,orange,yellow=<span class="number">200</span>,green,blue&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>这种情况下，orange的值是101,green=201,blue=202</strong></p>
<ol>
<li>创建枚举类型和枚举运算符<h4 id="声明枚举之后我们可以创建枚举类型："><a href="#声明枚举之后我们可以创建枚举类型：" class="headerlink" title="声明枚举之后我们可以创建枚举类型："></a>声明枚举之后我们可以创建枚举类型：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color band;<span class="comment">//band is a color type var</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>关于枚举类类型运算符，我们可以将一个枚举值赋给另一个枚举类型，但不能将一个非枚举类型的变量付给枚举类型：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">200</span>;</span><br><span class="line">red=blue;<span class="comment">// the way is ok</span></span><br><span class="line">red=a;<span class="comment">//the way is bad</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>但是可以通过强制类型转换，来将一个常规变量值强制赋给枚举：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">red=(color)<span class="number">30</span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>如果我们将非枚举类型a强制赋值给枚举类型red，有的编译器会报错，而有的会发出警告，具体的依据编译器而定。但是将一个枚举类型的值赋给一个常规变量是可以行的，比如将他提升为一个int类型：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b= blue;<span class="comment">//pass</span></span><br></pre></td></tr></table></figure></p>
<h4 id="对于枚举类型，只可以使用赋值运算符，不能对其使用算术运算符，例如下面的方式不可取："><a href="#对于枚举类型，只可以使用赋值运算符，不能对其使用算术运算符，例如下面的方式不可取：" class="headerlink" title="对于枚举类型，只可以使用赋值运算符，不能对其使用算术运算符，例如下面的方式不可取："></a>对于枚举类型，只可以使用赋值运算符，不能对其使用算术运算符，例如下面的方式不可取：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">band=red+green;<span class="comment">//no pass</span></span><br></pre></td></tr></table></figure>
<ol>
<li>匿名枚举<h3 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;number=<span class="number">2015</span>&#125;;<span class="comment">//build a number constant</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="在具体的开发工作当中，多使用这样的方式来代替const关键字创建常理"><a href="#在具体的开发工作当中，多使用这样的方式来代替const关键字创建常理" class="headerlink" title="在具体的开发工作当中，多使用这样的方式来代替const关键字创建常理"></a>在具体的开发工作当中，多使用这样的方式来代替const关键字创建常理</h3><ol>
<li>枚举的取值范围<br><strong>C++通过强制类型转换，可以将一个和法值赋给枚举，每个枚举值都是有取值范围的</strong><h3 id="取值范围的定义："><a href="#取值范围的定义：" class="headerlink" title="取值范围的定义："></a>取值范围的定义：</h3><em>首先找出上限，找出枚举量的最大值，找到大于这个最大值、最小的2的幂，在将它减去1,得到的就是枚举取值范围的上限，例如：</em><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bits&#123;one=<span class="number">-7</span>,two=<span class="number">2</span>,four=<span class="number">4</span>,eight=<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>上面的代码当中，最大值为8,大于这个最大值2的最小幂为16,即这个枚举的取值上限为15；最大值已经找到，那最小值呢？<br><em>关于最小值，原理和最大值的需找方法是一样的</em><br>在枚举bits当中，最小值为-7，比它小，最大的2的幂是-8,则下限为-7,取值范围的最小值就为-7。</p>
</blockquote>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2016/05/11/C-new-and-point/" >
  C++ new and point
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2016/05/11/C-new-and-point/"><span class="article-date">
  2016-05-11
</span>
</a>
        

        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C/">C++</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <h2 id="C-new和指针"><a href="#C-new和指针" class="headerlink" title="C++ new和指针"></a>C++ new和指针</h2><img src="/blog/2016/05/11/C-new-and-point/xing1.jpg" alt="这是一个装饰图" title="这是一个装饰图">
<h3 id="计算机在储存数据时我们必须跟踪三个属性："><a href="#计算机在储存数据时我们必须跟踪三个属性：" class="headerlink" title="计算机在储存数据时我们必须跟踪三个属性："></a>计算机在储存数据时我们必须跟踪三个属性：</h3><blockquote>
<ul>
<li>信息被储存在何处？</li>
<li>储存的值是多少？</li>
<li>储存的信息是什么类型</li>
</ul>
</blockquote>
<ol>
<li>声明一个指针<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *b=&amp;a;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>这里我们创建了a变量和指针b，并把a的地址赋给指针b，现在指针b储存的就是a在内存里的地址，我们可以通过b来访问a的值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a和 *b是等效的，他们的值都是<span class="number">100</span></span><br><span class="line">&amp;a和b是等效的，它们都是内存地址</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li><p>指针和C++运行原理<br><strong>oop强调的是运行阶段进行决策，运行阶段是指程序运行时，编译阶段是指编译器把程序组合起来，变成二进制文件，比如我们要创建一个数组，但是我们不知道数组在使用的时候要存多少数据，这时候不能把他的容量写死，而是让它在运行阶段根据实际情况来决定他的大小，例如：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];<span class="comment">//编译阶段分配19的固定大小内存</span></span><br><span class="line"><span class="keyword">int</span> a[]=new <span class="keyword">int</span>;<span class="comment">//运行阶段分配内存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针详细介绍</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a; <span class="comment">//指针名：a，指针指向的类型为：int，指针类型为：int *</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针的危险</p>
<h4 id="我们在创建指针时，计算机将分配用来储存地址的内存，但不会分配用来存储指针所指向的数据的内存，为数据提供空间是一个独立的步骤，如果忽略这一步骤将导致不可预测的后果。"><a href="#我们在创建指针时，计算机将分配用来储存地址的内存，但不会分配用来存储指针所指向的数据的内存，为数据提供空间是一个独立的步骤，如果忽略这一步骤将导致不可预测的后果。" class="headerlink" title="我们在创建指针时，计算机将分配用来储存地址的内存，但不会分配用来存储指针所指向的数据的内存，为数据提供空间是一个独立的步骤，如果忽略这一步骤将导致不可预测的后果。"></a>我们在创建指针时，计算机将分配用来储存地址的内存，但不会分配用来存储指针所指向的数据的内存，为数据提供空间是一个独立的步骤，如果忽略这一步骤将导致不可预测的后果。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> *fellow;</span><br><span class="line">*fellow=<span class="number">223323</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>上述代码没有将地址赋给指针，223323将被存在何处我们不得而知，由于fellow没有被初始化，它可能有任何的值，不管地址是什么，他将是储存223323的地址，如果fellow恰巧为1200,计算机将把数据储存在地址1200上，fellow所指向的地方可能并不是所要储存223323的地方，这种错误将导致不可预测的后果。<br><strong>注意：一定要在对指针解除引用运算符（*）之前，将指针初始化为一个确定的、适合的地址</strong></p>
<ol>
<li>使用new来分配内存<h4 id="在C语言中使用库函数malloc-函数来申请内存，C-同样也可以使用他，但是C-有更好的方法–new运算符-其实new运算符是在堆内存（heap）当中来申请内存，内存分为堆内存（heap）和栈内存（stack），以其他方式申请的内存都放到了栈内存中，申请和释放都由系统来完成，而堆内存则需要我们手动申请、释放。"><a href="#在C语言中使用库函数malloc-函数来申请内存，C-同样也可以使用他，但是C-有更好的方法–new运算符-其实new运算符是在堆内存（heap）当中来申请内存，内存分为堆内存（heap）和栈内存（stack），以其他方式申请的内存都放到了栈内存中，申请和释放都由系统来完成，而堆内存则需要我们手动申请、释放。" class="headerlink" title="在C语言中使用库函数malloc()函数来申请内存，C++同样也可以使用他，但是C++有更好的方法–new运算符,其实new运算符是在堆内存（heap）当中来申请内存，内存分为堆内存（heap）和栈内存（stack），以其他方式申请的内存都放到了栈内存中，申请和释放都由系统来完成，而堆内存则需要我们手动申请、释放。"></a>在C语言中使用库函数malloc()函数来申请内存，C++同样也可以使用他，但是C++有更好的方法–new运算符,其实new运算符是在堆内存（heap）当中来申请内存，内存分为堆内存（heap）和栈内存（stack），以其他方式申请的内存都放到了栈内存中，申请和释放都由系统来完成，而堆内存则需要我们手动申请、释放。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr=new <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>new int告诉程序，需要一块能够储存int大小的内存块，new根据类型来确定需要多少字节的内存，然后它找到这样的内存，并返回其地址，接下来地址会被赋给ptr。</p>
<ol>
<li>new和delete<h4 id="在前面我们已经说过，heap内存需要我们手动申请和释放，我们已经学会如何来申请内存，那么释放呢？"><a href="#在前面我们已经说过，heap内存需要我们手动申请和释放，我们已经学会如何来申请内存，那么释放呢？" class="headerlink" title="在前面我们已经说过，heap内存需要我们手动申请和释放，我们已经学会如何来申请内存，那么释放呢？"></a>在前面我们已经说过，heap内存需要我们手动申请和释放，我们已经学会如何来申请内存，那么释放呢？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;<span class="comment">//删除内存占用</span></span><br><span class="line">ptr=<span class="literal">NULL</span>;<span class="comment">//将指针置为空（安全起见）</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="对于使用new新建的数组应该怎样来释放内存"><a href="#对于使用new新建的数组应该怎样来释放内存" class="headerlink" title="对于使用new新建的数组应该怎样来释放内存"></a>对于使用new新建的数组应该怎样来释放内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *some=new some[];</span><br><span class="line"><span class="comment">/*使用some数组*/</span></span><br><span class="line"><span class="keyword">delete</span> []some;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里我们使用new来为some数组申请内存，对应就应该使用delete []some来释放内存，而不是使用delete some,这仅仅只清理了数组地一个元素所占的内存，及some[0],内存依然没有被清理干净，同样会发生内存泄漏的危险。</p>
<ol>
<li>数组与指针<br><strong>在C++中，数组在内存中是一个连续的片段，文章的开头我们已经说了，我们需要跟踪他的三个属性，其中我们不确定它在内存中的位置，因为数组的每个元素都有其地址。其实数组也是一个指针，当声明一个数组的时候，就以它的第一个元素的地址来作为他在内存当中的位置，比如：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> price [];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里的price和指针是一样的，加入我们试图输出price：std::cout&lt;&lt;price;这里将会输出一个内存地址，也就是说，数组就是指针。</p>
</blockquote>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2016/05/07/Cplusplus-struct/" >
  Cplusplus-struct
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2016/05/07/Cplusplus-struct/"><span class="article-date">
  2016-05-07
</span>
</a>
        

        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C/">C++</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <h1 id="C-结构体与共用体的使用"><a href="#C-结构体与共用体的使用" class="headerlink" title="C++结构体与共用体的使用"></a>C++结构体与共用体的使用</h1><img src="/blog/2016/05/07/Cplusplus-struct/xing3.jpg" alt="这是一个装饰图" title="这是一个装饰图">
<h4 id="比如我们需要一个数据类型用于储存某个人的年龄、性别、地址，这个时候需要用到结构体"><a href="#比如我们需要一个数据类型用于储存某个人的年龄、性别、地址，这个时候需要用到结构体" class="headerlink" title="比如我们需要一个数据类型用于储存某个人的年龄、性别、地址，这个时候需要用到结构体"></a>比如我们需要一个数据类型用于储存某个人的年龄、性别、地址，这个时候需要用到结构体</h4><ol>
<li><p>声明结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mystruct</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="built_in">string</span> sex;</span><br><span class="line">  <span class="built_in">string</span> address;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mystruct Jack=</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">30</span>,</span><br><span class="line">  <span class="string">"男"</span>，</span><br><span class="line">  <span class="string">"shanghai"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++11可以省略等号来初始化结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mystruct Xier</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">20</span>,</span><br><span class="line">  <span class="string">"女"</span>，</span><br><span class="line">  <span class="string">"Beijing"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们可以这样来声明并创建结构体对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inflatable</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span>[<span class="number">20</span>] name;</span><br><span class="line">  <span class="keyword">float</span> vulum;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">&#125;pal,jone;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>声明并创建了pal和jone</p>
</blockquote>
<ol>
<li><p>甚至可以这样做</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inflatable</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span>[<span class="number">20</span>] name;</span><br><span class="line">  <span class="keyword">float</span> volum;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">&#125;  mr_glitze =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"Jack"</span>,</span><br><span class="line">  <span class="number">0.20</span>,</span><br><span class="line">  <span class="number">20.30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问结构体元素<br><strong>访问结构体元素和用类对象访问函数和变量是一样的，使用: 对象名.变量名</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mr_glitze.name;<span class="comment">//访问到了Jack</span></span><br><span class="line">mr_glitze.price;<span class="comment">//访问到了20.30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结构数组<br><strong>我们可以像使用常规数组一样来使用结构数组，原理都是一样的</strong></p>
<blockquote>
<p>根据上面的例子，我创建了inflatable这个结构，就可以创建它的数组了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflatable gifts[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<h4 id="记住gifts是一个数组而不是结构，像gifts-price这样使用是无效的，gitfs包含每个元素（gifts-0-gifts-99-）都是inflatable的对象，我们可以这样来访问元素："><a href="#记住gifts是一个数组而不是结构，像gifts-price这样使用是无效的，gitfs包含每个元素（gifts-0-gifts-99-）都是inflatable的对象，我们可以这样来访问元素：" class="headerlink" title="记住gifts是一个数组而不是结构，像gifts.price这样使用是无效的，gitfs包含每个元素（gifts[0]~gifts[99]）都是inflatable的对象，我们可以这样来访问元素："></a>记住gifts是一个数组而不是结构，像gifts.price这样使用是无效的，gitfs包含每个元素（gifts[0]~gifts[99]）都是inflatable的对象，我们可以这样来访问元素：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gifts[<span class="number">2</span>].name;</span><br><span class="line">gifts[<span class="number">99</span>].price;</span><br></pre></td></tr></table></figure>
<h4 id="初始化结构数组"><a href="#初始化结构数组" class="headerlink" title="初始化结构数组"></a>初始化结构数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inflatable guest[<span class="number">2</span>]=</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">"Babil"</span>,<span class="number">0.5</span>,<span class="number">23.23</span> &#125;</span><br><span class="line">    &#123;<span class="string">"Godzilize"</span>,<span class="number">2000</span>,<span class="number">50.50</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>共用体<h4 id="在日常生活工作中，我们会遇到要储存一个不同类型的值，有时候它是整型、有时候是字符串类型，比如小李的公司每个部门给员工编号，每个部门的编号都不同，有的部门用整型数据给员工编号，而有的部门给员工起个绰号（字符串），这样当我们要把员工数据录入的时候就有麻烦了，所以这时候就要用共用体。"><a href="#在日常生活工作中，我们会遇到要储存一个不同类型的值，有时候它是整型、有时候是字符串类型，比如小李的公司每个部门给员工编号，每个部门的编号都不同，有的部门用整型数据给员工编号，而有的部门给员工起个绰号（字符串），这样当我们要把员工数据录入的时候就有麻烦了，所以这时候就要用共用体。" class="headerlink" title="在日常生活工作中，我们会遇到要储存一个不同类型的值，有时候它是整型、有时候是字符串类型，比如小李的公司每个部门给员工编号，每个部门的编号都不同，有的部门用整型数据给员工编号，而有的部门给员工起个绰号（字符串），这样当我们要把员工数据录入的时候就有麻烦了，所以这时候就要用共用体。"></a>在日常生活工作中，我们会遇到要储存一个不同类型的值，有时候它是整型、有时候是字符串类型，比如小李的公司每个部门给员工编号，每个部门的编号都不同，有的部门用整型数据给员工编号，而有的部门给员工起个绰号（字符串），这样当我们要把员工数据录入的时候就有麻烦了，所以这时候就要用共用体。</h4><blockquote>
<p>共用体的声明和结构体一样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> myUnion</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ID_int;</span><br><span class="line"><span class="built_in">string</span> ID_str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>现在就可以使用myUnion来储存int<br>变量和string变量了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myUnion mu;</span><br><span class="line">mu.ID_int=<span class="number">045311</span>;</span><br><span class="line">mu.ID_str=<span class="string">"令狐冲"</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>需要注意的是，共用体每次只能储存一个变量，第一次把ID_int初始化为045311,当我再次初始化ID_str的值时，原来的ID_int的内存将被清空，用来储存ID_str的值</strong></p>

        
      </div>
    </div>

  
    </div>
  






          <div class="main-footer">
  
    © 2016 LeekinBlog - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/blog/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/blog/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/blog/PhotoSwipe/photoswipe.js"></script>
  <script src="/blog/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/blog/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/blog/scripts/main.js"></script>

</body>
</html>
